from anytree import Node, RenderTree, find_by_attr, find
from utils import decoder



def make_tree(df, df_column_cat, root_name, display_tree= True):
  
  """Takes a data frame, a column of such dataframe and a string name
  Using anytree library generate the tree and print it, and return a dictionary 
  
  Parameters:
  df = pd.DataFrame a column data frame
  df_column_cat: a column of a data frame which values are a simple dictinary or a list of them
  root_name: str
  
  print the tree and
  Returns a dictionary with category name:str as keys and nodes as values 
  """
  #set the root node
  root = Node(root_name)
 
  # dictionary of nodes to be generated by the function
  nodes = {}
  nodes[root.name]: root

  # Iteration over rows
  for index, row in df.iterrows():
  # Iteration over index of values at each row
    c = df_column_cat[index]
    for i_cat in range(len(c)):
      cat_name = c[i_cat]['id'] 
      
      # Verify if the parent category exist if it does not exists appends it to the nodes list and creates the node. Else continues
      if i_cat == 0 and cat_name not in nodes:
        nodes[cat_name] = Node(cat_name, parent=find_by_attr(root, root_name))

      # Verify if the subcategory exists if it does not exists appends it to the nodes list and creates the node. Else continues  
      elif i_cat > 0 and cat_name not in nodes:
        predecessor = c[i_cat -1]['id'] 
        nodes[cat_name] = Node(cat_name, find_by_attr(root,predecessor))
      
      else: continue
  
  
  if display_tree:
    # Display the tree with id and decoded name for a better visualization 
    for pre, _, node in RenderTree(root):
      print("%s%s" % (pre, node.name + " - " + decoder.decode_id(node.name)))
    
  return nodes





def dist_nodes(node_nm1, node_nm2, cat_tree_dict):
    """Takes two nodes names categories and the dictionary generated by maketree() function and returns the distance between them using anytree libray
    input: str names of nodes
    return: int distance between nodes """

    cat_node1 = cat_tree_dict[node_nm1]
    cat_node2 = cat_tree_dict[node_nm2]

    path_list1 = list(cat_node1.path)[1:]
    path_list2 = list(cat_node2.path)[1:]
    
    len_list_path = [len(path_list1), len(path_list2)]
    
    if len(path_list1) == max(len_list_path):
      max_length_list = path_list1 
      min_length_list = path_list2
    else:
      max_length_list = path_list2
      min_length_list = path_list1
    
    dist = 0
    common_path = []
        

    for nd in max_length_list:
        if nd in min_length_list:
            common_path.append(nd)
            dist +=0
        else:
            dist += 1
    return dist 


def get_path_node_dict(cat_tree_dict):
  """Takes an id category and returns a list of strings with the decoded path from parent to child

  Parameters
  ----------
  node_nm: str category id 
  cat_tree_dict: dict dictionary generated by the make_tree() function
  """
  dict_path_node = {}
  
  for nodes in cat_tree_dict.values():
    path_node = []
    path_list = list(nodes.path)[1:]
    node = str(nodes).split('/')[-1].strip("')")
    for items in path_list:
        node_path = str(items).split('/')[-1].strip("')")
        path_node.append(decoder.decode_id(node_path))
        dict_path_node[node] = path_node
  return dict_path_node
